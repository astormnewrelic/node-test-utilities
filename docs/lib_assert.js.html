<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/assert.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/assert.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

var _ = require('lodash')
var TestAgent = require('./agent')
var Transaction = require('newrelic/lib/transaction')
var util = require('util')


/**
 * @namespace assert
 */
var assert = module.exports

/**
 * Extends Tap with more assert specific to testing transactions.
 *
 * @param {Tap} tap - The Tap module as returned by `require('tap')`.
 */
assert.extendTap = function extendTap(tap) {
  var addAssert = tap.Test.prototype.addAssert.bind(tap.Test.prototype)
  addAssert('transaction', 1, _tapper1(_transactionTest))

  addAssert('metrics', 1, _tapper1(_metricsTest))
  addAssert('exactMetrics', 1, _tapper1(_exactMetricsTest))

  addAssert('segments', 2, _tapper2(_segmentsTest))
  addAssert('exactSegments', 2, _tapper2(_exactSegmentsTest))
}

/**
 * Asserts that the provided object is a transaction and is the currently active
 * transaction.
 *
 * @function
 *
 * @param {*}       tx        - The object to test as a transaction.
 * @param {string}  [message] - Optional message for the assertion.
 */
assert.transaction = _asserter1(_transactionTest)

/**
 * Asserts that the metrics are roughly the same shape as expected.
 *
 * @function
 *
 * @param {Array.&lt;(string|Object)>} expected
 *  Array of expected metrics. Any value that is a string will just be checked
 *  against a metric name.
 *
 * @param {string} expected[].name
 *  The name of the metric.
 *
 * @param {string} [expected[].scope]
 *  Optional scope that the metric can be found in.
 *
 * @param {number} [expected[].min]
 *  Optional metric value to check.
 *
 * @param {number} [expected[].max]
 *  Optional metric value to check.
 *
 * @param {number} [expected[].sumOfSquares]
 *  Optional metric value to check.
 *
 * @param {number} [expected[].callCount]
 *  Optional metric value to check.
 *
 * @param {number} [expected[].total]
 *  Optional metric value to check.
 */
assert.metrics = _asserter1(_metricsTest)

/**
 * Asserts that only the given metrics were recorded and no others.
 *
 * @function
 *
 * @param {Array.&lt;(string|Object)>} expected
 *  Array of expected metrics. Any value that is a string will just be checked
 *  against a metric name.
 *
 * @param {string} expected[].name
 *  The name of the metric.
 *
 * @param {string} [expected[].scope]
 *  Optional scope that the metric can be found in.
 *
 * @param {number} [expected[].min]
 *  Optional metric value to check.
 *
 * @param {number} [expected[].max]
 *  Optional metric value to check.
 *
 * @param {number} [expected[].sumOfSquares]
 *  Optional metric value to check.
 *
 * @param {number} [expected[].callCount]
 *  Optional metric value to check.
 *
 * @param {number} [expected[].total]
 *  Optional metric value to check.
 */
assert.exactMetrics = _asserter1(_exactMetricsTest)

/**
 * Asserts that the segments are roughly structured as expected.
 *
 * Ordering of children as well as amount of children are not considered as part
 * of this assertion. In addition, the name is only loosely matched; the segment
 * name need only _contain_ the provided string.
 *
 * @function
 *
 * @param {TraceSegment} parent
 *  The segment to check the children of.
 *
 * @param {Object[]} expected
 *  The expected children.
 *
 * @param {string|RegExp} expected[].name
 *  The name of the segment. If a string, then `indexOf` will be used to compare
 *  segment names.
 *
 * @param {Object[]} expected[].children
 *  An array of expected children. This should match the same structure as the
 *  `expected` parameter.
 *
 * @param {bool} [expected[].exact=false]
 *  Indicates if the children should be matched exactly. If `exact: true` is
 *  given then from these children on, until `exact: false` is specified,
 *  segments will be compared strictly.
 */
assert.segments = _asserter2(_segmentsTest)

/**
 * Asserts that the segments are exactly structured as expected.
 *
 * Ordering of children as well as the amount of children are strictly checked
 * as part of this assertion. In addition, the name must be provided in full.
 *
 * @function
 *
 * @param {TraceSegment} parent
 *  The segment to check the children of.
 *
 * @param {Object[]} expected
 *  The expected children.
 *
 * @param {string} expected[].name
 *  The full and exact name of the segment.
 *
 * @param {Object[]} expected[].children
 *  An array of all expected children. This should match the same structure as
 *  the `expected` parameter.
 *
 * @param {bool} [expected[].exact=true]
 *  Indicates if the children should be matched exactly. If `exact: false` is
 *  given then from these children on, until `exact: true` is specified,
 *  segments will be compared loosely.
 */
assert.exactSegments = _asserter2(_exactSegmentsTest)


function _transactionTest(tx) {
  var currentTx = TestAgent.instance &amp;&amp; TestAgent.instance.getTransaction()
  if (tx === null || tx === undefined) {
    return 'Transaction is null.'
  } else if (!(tx instanceof Transaction)) {
    return 'Transaction is not an instance of Transaction class.'
  } else if (!currentTx || tx.id !== currentTx.id) {
    return util.format(
      'Transaction (%s) is not the current transaction (%s)',
      tx.id, currentTx ? currentTx.id : '&lt;null>'
    )
  }

  return null
}

function _metricsTest(expected, exact) {
  var metrics = TestAgent.instance.agent.metrics

  for (var i = 0; i &lt; expected.length; ++i) {
    var expectedMetric = _.clone(expected[i])
    var name = null
    var scope = null

    if (_.isString(expectedMetric)) {
      name = expectedMetric
      expectedMetric = {}
    } else {
      name = expectedMetric.name
      scope = expectedMetric.scope
      delete expectedMetric.name
      delete expectedMetric.scope
    }

    var metric = metrics.getMetric(name, scope)
    if (!metric) {
      return util.format(
        'Missing metric named "%s" in scope %s',
        name, scope || '&lt;null>'
      )
    }

    // Note that if expectedMetric is empty (i.e. only name and scope given)
    // then this `isMatch` will be true, effectively disabling this check.
    if (!_.isMatch(metric, expectedMetric)) {
      return util.format('Metric %s does not match expected.', name)
    }
  }

  if (exact &amp;&amp; metrics.toJSON().length !== expected.length) {
    return util.format(
      'Metric has %d elements, expected %d.',
      metrics.toJSON().length, expected.length
    )
  }

  return null
}

function _exactMetricsTest(expected) {
  return _metricsTest(expected, true)
}

function _segmentsTest(parent, _expected) {
  // expected:
  //  [{name: "name", children: [{name: "child"}]}]
  var stack = [[parent.children, _expected]]

  var findChild = function findChild(children, name) {
    // FIXME: Change to `.find` after deprecating 0.10 and 0.12.
    return children.filter(function findChild_childrenFind(child) {
      if (name instanceof RegExp) {
        return name.test(child.name)
      }
      return child.name.indexOf(name) >= 0
    })[0] // &lt;-- FIXME remove this too.
  }

  while (stack.length) {
    var current = stack.pop()
    var children = current[0]
    var expected = current[1]

    for (var i = 0; i &lt; expected.length; ++i) {
      var expectedChild = expected[i]
      var child = findChild(children, expectedChild.name)

      if (!child) {
        return util.format('Missing child segment "%s"', expectedChild.name)
      }

      if (expectedChild.children) {
        if (expectedChild.exact) {
          var err = _exactSegmentsTest(child, expectedChild.children)
          if (err) {
            return err
          }
        } else {
          stack.push([child.children, expectedChild.children])
        }
      }
    }
  }

  return null
}

function _exactSegmentsTest(parent, _expected) {
  var stack = [[parent.children, _expected]]

  while (stack.length) {
    var current = stack.pop()
    var children = current[0]
    var expected = current[1]

    for (var i = 0; i &lt; expected.length; ++i) {
      var expectedChild = expected[i]
      var child = children[i]
      if (!child) {
        return util.format(
          'Expected segment "%s" as child %d of "%s", found no child.',
          expectedChild.name, i, parent.name
        )
      }
      if (child.name !== expectedChild.name) {
        return util.format(
          'Expected segment "%s" as child %d of "%s", found "%s" instead.',
          expectedChild.name, i, parent.name, child.name
        )
      }

      if (expectedChild.children) {
        if (expectedChild.exact === false) {
          var err = _segmentsTest(child, expectedChild.children)
          if (err) {
            return err
          }
        } else {
          stack.push([child.children, expectedChild.children])
        }
      }
    }

    if (children.length !== expected.length) {
      return util.format(
        'Expected %d children for segment "%s", found %d instead.',
        expected.length, parent.name, children.length
      )
    }
  }

  return null
}


function _asserter1(test) {
  return function asertionTest(x, message) {
    var err = test(x)
    if (err) {
      throw new Error(message || err)
    }
  }
}

function _asserter2(test) {
  return function asertionTest(x, y, message) {
    var err = test(x, y)
    if (err) {
      throw new Error(message || err)
    }
  }
}

function _tapper1(test) {
  return function tapTest(x, message, extra) {
    var err = test(x)
    if (err) {
      return this.fail(message || err, extra)
    }
    return this.pass(message, extra)
  }
}

function _tapper2(test) {
  return function tapTest(x, y, message, extra) {
    var err = test(x, y)
    if (err) {
      return this.fail(message || err, extra)
    }
    return this.pass(message, extra)
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-test-utilities.html">test-utilities</a></li></ul><h3>Classes</h3><ul><li><a href="TestAgent.html">TestAgent</a></li></ul><h3>Namespaces</h3><ul><li><a href="assert.html">assert</a></li><li><a href="util.html">util</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Jan 24 2017 16:42:43 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
